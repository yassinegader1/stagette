/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { Platform } from '@angular/cdk/platform';
import { AfterContentInit, ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, NgZone } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { CanColor, CanDisable, CanDisableRipple, HammerInput, HasTabIndex, MatRipple } from '@angular/material/core';
import { MatSlideToggleDefaultOptions } from './slide-toggle-config';
import * as ɵngcc0 from '@angular/core';
export declare const MAT_SLIDE_TOGGLE_VALUE_ACCESSOR: any;
/** Change event object emitted by a MatSlideToggle. */
export declare class MatSlideToggleChange {
    /** The source MatSlideToggle of the event. */
    source: MatSlideToggle;
    /** The new `checked` value of the MatSlideToggle. */
    checked: boolean;
    constructor(
        /** The source MatSlideToggle of the event. */
        source: MatSlideToggle, 
        /** The new `checked` value of the MatSlideToggle. */
        checked: boolean);
}
/** @docs-private */
export declare class MatSlideToggleBase {
    _elementRef: ElementRef;
    constructor(_elementRef: ElementRef);
}
export declare const _MatSlideToggleMixinBase: (new (...args: any[]) => HasTabIndex) & (new (...args: any[]) => CanColor) & (new (...args: any[]) => CanDisableRipple) & (new (...args: any[]) => CanDisable) & typeof MatSlideToggleBase;
/** Represents a slidable "switch" toggle that can be moved between on and off. */
export declare class MatSlideToggle extends _MatSlideToggleMixinBase implements OnDestroy, AfterContentInit, ControlValueAccessor, CanDisable, CanColor, HasTabIndex, CanDisableRipple {
    private _focusMonitor;
    private _changeDetectorRef;
    private _ngZone;
    defaults: MatSlideToggleDefaultOptions;
    _animationMode: string | undefined;
    private _dir;
    private onChange;
    private onTouched;
    private _uniqueId;
    private _required;
    private _checked;
    /** Reference to the focus state ripple. */
    private _focusRipple;
    /** Whether the thumb is currently being dragged. */
    private _dragging;
    /** Previous checked state before drag started. */
    private _previousChecked;
    /** Width of the thumb bar of the slide-toggle. */
    private _thumbBarWidth;
    /** Percentage of the thumb while dragging. Percentage as fraction of 100. */
    private _dragPercentage;
    /** Reference to the thumb HTMLElement. */
    _thumbEl: ElementRef;
    /** Reference to the thumb bar HTMLElement. */
    _thumbBarEl: ElementRef;
    /** Name value will be applied to the input element if present */
    name: string | null;
    /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */
    id: string;
    /** Whether the label should appear after or before the slide-toggle. Defaults to 'after' */
    labelPosition: 'before' | 'after';
    /** Whether the slide-toggle element is checked or not */
    /** Used to set the aria-label attribute on the underlying input element. */
    ariaLabel: string | null;
    /** Used to set the aria-labelledby attribute on the underlying input element. */
    ariaLabelledby: string | null;
    /** Whether the slide-toggle is required. */
    required: boolean;
    /** Whether the slide-toggle element is checked or not */
    checked: boolean;
    /** An event will be dispatched each time the slide-toggle changes its value. */
    readonly change: EventEmitter<MatSlideToggleChange>;
    /**
     * An event will be dispatched each time the slide-toggle input is toggled.
     * This event always fire when user toggle the slide toggle, but does not mean the slide toggle's
     * value is changed. The event does not fire when user drag to change the slide toggle value.
     */
    readonly toggleChange: EventEmitter<void>;
    /**
     * An event will be dispatched each time the slide-toggle is dragged.
     * This event always fire when user drag the slide toggle to make a change that greater than 50%.
     * It does not mean the slide toggle's value is changed. The event does not fire when user toggle
     * the slide toggle to change the slide toggle's value.
     */
    readonly dragChange: EventEmitter<void>;
    /** Returns the unique id for the visual hidden input. */
    readonly inputId: string;
    /** Reference to the underlying input element. */
    _inputElement: ElementRef<HTMLInputElement>;
    /** Reference to the ripple directive on the thumb container. */
    _ripple: MatRipple;
    constructor(elementRef: ElementRef, 
        /**
         * @deprecated The `_platform` parameter to be removed.
         * @breaking-change 7.0.0
         */
        _platform: Platform, _focusMonitor: FocusMonitor, _changeDetectorRef: ChangeDetectorRef, tabIndex: string, _ngZone: NgZone, defaults: MatSlideToggleDefaultOptions, _animationMode?: string | undefined, _dir?: Directionality | undefined);
    ngAfterContentInit(): void;
    ngOnDestroy(): void;
    /** Method being called whenever the underlying input emits a change event. */
    _onChangeEvent(event: Event): void;
    /** Method being called whenever the slide-toggle has been clicked. */
    _onInputClick(event: Event): void;
    /** Implemented as part of ControlValueAccessor. */
    writeValue(value: any): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnChange(fn: any): void;
    /** Implemented as part of ControlValueAccessor. */
    registerOnTouched(fn: any): void;
    /** Implemented as a part of ControlValueAccessor. */
    setDisabledState(isDisabled: boolean): void;
    /** Focuses the slide-toggle. */
    focus(): void;
    /** Toggles the checked state of the slide-toggle. */
    toggle(): void;
    /** Function is called whenever the focus changes for the input element. */
    private _onInputFocusChange(focusOrigin);
    /**
     * Emits a change event on the `change` output. Also notifies the FormControl about the change.
     */
    private _emitChangeEvent();
    /** Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100. */
    private _getDragPercentage(distance);
    _onDragStart(): void;
    _onDrag(event: HammerInput): void;
    _onDragEnd(): void;
    /** Method being called whenever the label text changes. */
    _onLabelTextChange(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MatSlideToggle, [null, null, null, null, { attribute: "tabindex"; }, null, null, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MatSlideToggle, "mat-slide-toggle", ["matSlideToggle"], { "disabled": "disabled"; "disableRipple": "disableRipple"; "color": "color"; "tabIndex": "tabIndex"; "name": "name"; "id": "id"; "labelPosition": "labelPosition"; "ariaLabel": "aria-label"; "ariaLabelledby": "aria-labelledby"; "required": "required"; "checked": "checked"; }, { "change": "change"; "toggleChange": "toggleChange"; "dragChange": "dragChange"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGUtdG9nZ2xlLmQudHMiLCJzb3VyY2VzIjpbInNsaWRlLXRvZ2dsZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7IEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ2FuQ29sb3IsIENhbkRpc2FibGUsIENhbkRpc2FibGVSaXBwbGUsIEhhbW1lcklucHV0LCBIYXNUYWJJbmRleCwgTWF0UmlwcGxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBNYXRTbGlkZVRvZ2dsZURlZmF1bHRPcHRpb25zIH0gZnJvbSAnLi9zbGlkZS10b2dnbGUtY29uZmlnJztcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1BVF9TTElERV9UT0dHTEVfVkFMVUVfQUNDRVNTT1I6IGFueTtcbi8qKiBDaGFuZ2UgZXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgYSBNYXRTbGlkZVRvZ2dsZS4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdFNsaWRlVG9nZ2xlQ2hhbmdlIHtcbiAgICAvKiogVGhlIHNvdXJjZSBNYXRTbGlkZVRvZ2dsZSBvZiB0aGUgZXZlbnQuICovXG4gICAgc291cmNlOiBNYXRTbGlkZVRvZ2dsZTtcbiAgICAvKiogVGhlIG5ldyBgY2hlY2tlZGAgdmFsdWUgb2YgdGhlIE1hdFNsaWRlVG9nZ2xlLiAqL1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKiBUaGUgc291cmNlIE1hdFNsaWRlVG9nZ2xlIG9mIHRoZSBldmVudC4gKi9cbiAgICAgICAgc291cmNlOiBNYXRTbGlkZVRvZ2dsZSwgXG4gICAgICAgIC8qKiBUaGUgbmV3IGBjaGVja2VkYCB2YWx1ZSBvZiB0aGUgTWF0U2xpZGVUb2dnbGUuICovXG4gICAgICAgIGNoZWNrZWQ6IGJvb2xlYW4pO1xufVxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdFNsaWRlVG9nZ2xlQmFzZSB7XG4gICAgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpO1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgX01hdFNsaWRlVG9nZ2xlTWl4aW5CYXNlOiAobmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gSGFzVGFiSW5kZXgpICYgKG5ldyAoLi4uYXJnczogYW55W10pID0+IENhbkNvbG9yKSAmIChuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBDYW5EaXNhYmxlUmlwcGxlKSAmIChuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBDYW5EaXNhYmxlKSAmIHR5cGVvZiBNYXRTbGlkZVRvZ2dsZUJhc2U7XG4vKiogUmVwcmVzZW50cyBhIHNsaWRhYmxlIFwic3dpdGNoXCIgdG9nZ2xlIHRoYXQgY2FuIGJlIG1vdmVkIGJldHdlZW4gb24gYW5kIG9mZi4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hdFNsaWRlVG9nZ2xlIGV4dGVuZHMgX01hdFNsaWRlVG9nZ2xlTWl4aW5CYXNlIGltcGxlbWVudHMgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBDb250cm9sVmFsdWVBY2Nlc3NvciwgQ2FuRGlzYWJsZSwgQ2FuQ29sb3IsIEhhc1RhYkluZGV4LCBDYW5EaXNhYmxlUmlwcGxlIHtcbiAgICBwcml2YXRlIF9mb2N1c01vbml0b3I7XG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgcHJpdmF0ZSBfbmdab25lO1xuICAgIGRlZmF1bHRzOiBNYXRTbGlkZVRvZ2dsZURlZmF1bHRPcHRpb25zO1xuICAgIF9hbmltYXRpb25Nb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfZGlyO1xuICAgIHByaXZhdGUgb25DaGFuZ2U7XG4gICAgcHJpdmF0ZSBvblRvdWNoZWQ7XG4gICAgcHJpdmF0ZSBfdW5pcXVlSWQ7XG4gICAgcHJpdmF0ZSBfcmVxdWlyZWQ7XG4gICAgcHJpdmF0ZSBfY2hlY2tlZDtcbiAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBmb2N1cyBzdGF0ZSByaXBwbGUuICovXG4gICAgcHJpdmF0ZSBfZm9jdXNSaXBwbGU7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHRodW1iIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkLiAqL1xuICAgIHByaXZhdGUgX2RyYWdnaW5nO1xuICAgIC8qKiBQcmV2aW91cyBjaGVja2VkIHN0YXRlIGJlZm9yZSBkcmFnIHN0YXJ0ZWQuICovXG4gICAgcHJpdmF0ZSBfcHJldmlvdXNDaGVja2VkO1xuICAgIC8qKiBXaWR0aCBvZiB0aGUgdGh1bWIgYmFyIG9mIHRoZSBzbGlkZS10b2dnbGUuICovXG4gICAgcHJpdmF0ZSBfdGh1bWJCYXJXaWR0aDtcbiAgICAvKiogUGVyY2VudGFnZSBvZiB0aGUgdGh1bWIgd2hpbGUgZHJhZ2dpbmcuIFBlcmNlbnRhZ2UgYXMgZnJhY3Rpb24gb2YgMTAwLiAqL1xuICAgIHByaXZhdGUgX2RyYWdQZXJjZW50YWdlO1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRodW1iIEhUTUxFbGVtZW50LiAqL1xuICAgIF90aHVtYkVsOiBFbGVtZW50UmVmO1xuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHRodW1iIGJhciBIVE1MRWxlbWVudC4gKi9cbiAgICBfdGh1bWJCYXJFbDogRWxlbWVudFJlZjtcbiAgICAvKiogTmFtZSB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgaWYgcHJlc2VudCAqL1xuICAgIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgLyoqIEEgdW5pcXVlIGlkIGZvciB0aGUgc2xpZGUtdG9nZ2xlIGlucHV0LiBJZiBub25lIGlzIHN1cHBsaWVkLCBpdCB3aWxsIGJlIGF1dG8tZ2VuZXJhdGVkLiAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGxhYmVsIHNob3VsZCBhcHBlYXIgYWZ0ZXIgb3IgYmVmb3JlIHRoZSBzbGlkZS10b2dnbGUuIERlZmF1bHRzIHRvICdhZnRlcicgKi9cbiAgICBsYWJlbFBvc2l0aW9uOiAnYmVmb3JlJyB8ICdhZnRlcic7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHNsaWRlLXRvZ2dsZSBlbGVtZW50IGlzIGNoZWNrZWQgb3Igbm90ICovXG4gICAgLyoqIFVzZWQgdG8gc2V0IHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvbiB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgIGFyaWFMYWJlbDogc3RyaW5nIHwgbnVsbDtcbiAgICAvKiogVXNlZCB0byBzZXQgdGhlIGFyaWEtbGFiZWxsZWRieSBhdHRyaWJ1dGUgb24gdGhlIHVuZGVybHlpbmcgaW5wdXQgZWxlbWVudC4gKi9cbiAgICBhcmlhTGFiZWxsZWRieTogc3RyaW5nIHwgbnVsbDtcbiAgICAvKiogV2hldGhlciB0aGUgc2xpZGUtdG9nZ2xlIGlzIHJlcXVpcmVkLiAqL1xuICAgIHJlcXVpcmVkOiBib29sZWFuO1xuICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgZWxlbWVudCBpcyBjaGVja2VkIG9yIG5vdCAqL1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgLyoqIEFuIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgdGhlIHNsaWRlLXRvZ2dsZSBjaGFuZ2VzIGl0cyB2YWx1ZS4gKi9cbiAgICByZWFkb25seSBjaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXRTbGlkZVRvZ2dsZUNoYW5nZT47XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgd2lsbCBiZSBkaXNwYXRjaGVkIGVhY2ggdGltZSB0aGUgc2xpZGUtdG9nZ2xlIGlucHV0IGlzIHRvZ2dsZWQuXG4gICAgICogVGhpcyBldmVudCBhbHdheXMgZmlyZSB3aGVuIHVzZXIgdG9nZ2xlIHRoZSBzbGlkZSB0b2dnbGUsIGJ1dCBkb2VzIG5vdCBtZWFuIHRoZSBzbGlkZSB0b2dnbGUnc1xuICAgICAqIHZhbHVlIGlzIGNoYW5nZWQuIFRoZSBldmVudCBkb2VzIG5vdCBmaXJlIHdoZW4gdXNlciBkcmFnIHRvIGNoYW5nZSB0aGUgc2xpZGUgdG9nZ2xlIHZhbHVlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IHRvZ2dsZUNoYW5nZTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgdGhlIHNsaWRlLXRvZ2dsZSBpcyBkcmFnZ2VkLlxuICAgICAqIFRoaXMgZXZlbnQgYWx3YXlzIGZpcmUgd2hlbiB1c2VyIGRyYWcgdGhlIHNsaWRlIHRvZ2dsZSB0byBtYWtlIGEgY2hhbmdlIHRoYXQgZ3JlYXRlciB0aGFuIDUwJS5cbiAgICAgKiBJdCBkb2VzIG5vdCBtZWFuIHRoZSBzbGlkZSB0b2dnbGUncyB2YWx1ZSBpcyBjaGFuZ2VkLiBUaGUgZXZlbnQgZG9lcyBub3QgZmlyZSB3aGVuIHVzZXIgdG9nZ2xlXG4gICAgICogdGhlIHNsaWRlIHRvZ2dsZSB0byBjaGFuZ2UgdGhlIHNsaWRlIHRvZ2dsZSdzIHZhbHVlLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRyYWdDaGFuZ2U6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKiogUmV0dXJucyB0aGUgdW5pcXVlIGlkIGZvciB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dC4gKi9cbiAgICByZWFkb25seSBpbnB1dElkOiBzdHJpbmc7XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBpbnB1dCBlbGVtZW50LiAqL1xuICAgIF9pbnB1dEVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgcmlwcGxlIGRpcmVjdGl2ZSBvbiB0aGUgdGh1bWIgY29udGFpbmVyLiAqL1xuICAgIF9yaXBwbGU6IE1hdFJpcHBsZTtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFRoZSBgX3BsYXRmb3JtYCBwYXJhbWV0ZXIgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgICogQGJyZWFraW5nLWNoYW5nZSA3LjAuMFxuICAgICAgICAgKi9cbiAgICAgICAgX3BsYXRmb3JtOiBQbGF0Zm9ybSwgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLCBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCB0YWJJbmRleDogc3RyaW5nLCBfbmdab25lOiBOZ1pvbmUsIGRlZmF1bHRzOiBNYXRTbGlkZVRvZ2dsZURlZmF1bHRPcHRpb25zLCBfYW5pbWF0aW9uTW9kZT86IHN0cmluZyB8IHVuZGVmaW5lZCwgX2Rpcj86IERpcmVjdGlvbmFsaXR5IHwgdW5kZWZpbmVkKTtcbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKiBNZXRob2QgYmVpbmcgY2FsbGVkIHdoZW5ldmVyIHRoZSB1bmRlcmx5aW5nIGlucHV0IGVtaXRzIGEgY2hhbmdlIGV2ZW50LiAqL1xuICAgIF9vbkNoYW5nZUV2ZW50KGV2ZW50OiBFdmVudCk6IHZvaWQ7XG4gICAgLyoqIE1ldGhvZCBiZWluZyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHNsaWRlLXRvZ2dsZSBoYXMgYmVlbiBjbGlja2VkLiAqL1xuICAgIF9vbklucHV0Q2xpY2soZXZlbnQ6IEV2ZW50KTogdm9pZDtcbiAgICAvKiogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIC8qKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLiAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqIEltcGxlbWVudGVkIGFzIGEgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKiBGb2N1c2VzIHRoZSBzbGlkZS10b2dnbGUuICovXG4gICAgZm9jdXMoKTogdm9pZDtcbiAgICAvKiogVG9nZ2xlcyB0aGUgY2hlY2tlZCBzdGF0ZSBvZiB0aGUgc2xpZGUtdG9nZ2xlLiAqL1xuICAgIHRvZ2dsZSgpOiB2b2lkO1xuICAgIC8qKiBGdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIGZvY3VzIGNoYW5nZXMgZm9yIHRoZSBpbnB1dCBlbGVtZW50LiAqL1xuICAgIHByaXZhdGUgX29uSW5wdXRGb2N1c0NoYW5nZShmb2N1c09yaWdpbik7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYSBjaGFuZ2UgZXZlbnQgb24gdGhlIGBjaGFuZ2VgIG91dHB1dC4gQWxzbyBub3RpZmllcyB0aGUgRm9ybUNvbnRyb2wgYWJvdXQgdGhlIGNoYW5nZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAvKiogUmV0cmlldmVzIHRoZSBwZXJjZW50YWdlIG9mIHRodW1iIGZyb20gdGhlIG1vdmVkIGRpc3RhbmNlLiBQZXJjZW50YWdlIGFzIGZyYWN0aW9uIG9mIDEwMC4gKi9cbiAgICBwcml2YXRlIF9nZXREcmFnUGVyY2VudGFnZShkaXN0YW5jZSk7XG4gICAgX29uRHJhZ1N0YXJ0KCk6IHZvaWQ7XG4gICAgX29uRHJhZyhldmVudDogSGFtbWVySW5wdXQpOiB2b2lkO1xuICAgIF9vbkRyYWdFbmQoKTogdm9pZDtcbiAgICAvKiogTWV0aG9kIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgbGFiZWwgdGV4dCBjaGFuZ2VzLiAqL1xuICAgIF9vbkxhYmVsVGV4dENoYW5nZSgpOiB2b2lkO1xufVxuIl19