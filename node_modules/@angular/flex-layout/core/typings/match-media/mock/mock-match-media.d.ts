/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgZone } from '@angular/core';
import { MatchMedia } from '../match-media';
import { BreakPointRegistry } from '../../breakpoints/break-point-registry';
/**
 * MockMatchMedia mocks calls to the Window API matchMedia with a build of a simulated
 * MockMediaQueryListener. Methods are available to simulate an activation of a mediaQuery
 * range and to clearAll mediaQuery listeners.
 */
import * as ɵngcc0 from '@angular/core';
export declare class MockMatchMedia extends MatchMedia {
    private _breakpoints;
    /** Special flag used to test BreakPoint registrations with MatchMedia */
    autoRegisterQueries: boolean;
    /**
     * Allow fallback to overlapping mediaQueries to determine
     * activatedInput(s).
     */
    useOverlaps: boolean;
    protected _registry: Map<string, MockMediaQueryList>;
    constructor(_zone: NgZone, _platformId: Object, _document: any, _breakpoints: BreakPointRegistry);
    /** Easy method to clear all listeners for all mediaQueries */
    clearAll(): void;
    /** Feature to support manual, simulated activation of a mediaQuery. */
    activate(mediaQuery: string, useOverlaps?: boolean): boolean;
    /** Converts an optional mediaQuery alias to a specific, valid mediaQuery */
    _validateQuery(queryOrAlias: string): string;
    /**
     * Manually activate any overlapping mediaQueries to simulate
     * similar functionality in the window.matchMedia()
     */
    private _activateWithOverlaps;
    /**
     *
     */
    private _activateByAlias;
    /**
     *
     */
    private _activateByQuery;
    /** Deactivate all current Mock MQLs */
    private _deactivateAll;
    /** Insure the mediaQuery is registered with MatchMedia */
    private _registerMediaQuery;
    /**
     * Call window.matchMedia() to build a MediaQueryList; which
     * supports 0..n listeners for activation/deactivation
     */
    protected _buildMQL(query: string): MediaQueryList;
    protected readonly hasActivated: boolean;
    private _actives;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MockMatchMedia, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<MockMatchMedia>;
}
/**
 * Special internal class to simulate a MediaQueryList and
 * - supports manual activation to simulate mediaQuery matching
 * - manages listeners
 */
export declare class MockMediaQueryList implements MediaQueryList {
    private _mediaQuery;
    private _isActive;
    private _listeners;
    readonly matches: boolean;
    readonly media: string;
    constructor(_mediaQuery: string);
    /**
     * Destroy the current list by deactivating the
     * listeners and clearing the internal list
     */
    destroy(): void;
    /** Notify all listeners that 'matches === TRUE' */
    activate(): MockMediaQueryList;
    /** Notify all listeners that 'matches === false' */
    deactivate(): MockMediaQueryList;
    /** Add a listener to our internal list to activate later */
    addListener(listener: MediaQueryListListener): void;
    /** Don't need to remove listeners in the testing environment */
    removeListener(_: EventListenerOrEventListenerObject | null): void;
    addEventListener<K extends keyof MediaQueryListEventMap>(_: K, __: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, ___?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof MediaQueryListEventMap>(_: K, __: (this: MediaQueryList, ev: MediaQueryListEventMap[K]) => any, ___?: boolean | EventListenerOptions): void;
    dispatchEvent(_: Event): boolean;
    onchange: MediaQueryListListener;
}
/**
 * Pre-configured provider for MockMatchMedia
 */
export declare const MockMatchMediaProvider: {
    provide: typeof MatchMedia;
    useClass: typeof MockMatchMedia;
};
declare type MediaQueryListListener = ((this: MediaQueryList, ev: MediaQueryListEvent) => any) | null;
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1tYXRjaC1tZWRpYS5kLnRzIiwic291cmNlcyI6WyJtb2NrLW1hdGNoLW1lZGlhLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1hdGNoTWVkaWEgfSBmcm9tICcuLi9tYXRjaC1tZWRpYSc7XG5pbXBvcnQgeyBCcmVha1BvaW50UmVnaXN0cnkgfSBmcm9tICcuLi8uLi9icmVha3BvaW50cy9icmVhay1wb2ludC1yZWdpc3RyeSc7XG4vKipcbiAqIE1vY2tNYXRjaE1lZGlhIG1vY2tzIGNhbGxzIHRvIHRoZSBXaW5kb3cgQVBJIG1hdGNoTWVkaWEgd2l0aCBhIGJ1aWxkIG9mIGEgc2ltdWxhdGVkXG4gKiBNb2NrTWVkaWFRdWVyeUxpc3RlbmVyLiBNZXRob2RzIGFyZSBhdmFpbGFibGUgdG8gc2ltdWxhdGUgYW4gYWN0aXZhdGlvbiBvZiBhIG1lZGlhUXVlcnlcbiAqIHJhbmdlIGFuZCB0byBjbGVhckFsbCBtZWRpYVF1ZXJ5IGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTW9ja01hdGNoTWVkaWEgZXh0ZW5kcyBNYXRjaE1lZGlhIHtcbiAgICBwcml2YXRlIF9icmVha3BvaW50cztcbiAgICAvKiogU3BlY2lhbCBmbGFnIHVzZWQgdG8gdGVzdCBCcmVha1BvaW50IHJlZ2lzdHJhdGlvbnMgd2l0aCBNYXRjaE1lZGlhICovXG4gICAgYXV0b1JlZ2lzdGVyUXVlcmllczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBbGxvdyBmYWxsYmFjayB0byBvdmVybGFwcGluZyBtZWRpYVF1ZXJpZXMgdG8gZGV0ZXJtaW5lXG4gICAgICogYWN0aXZhdGVkSW5wdXQocykuXG4gICAgICovXG4gICAgdXNlT3ZlcmxhcHM6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIF9yZWdpc3RyeTogTWFwPHN0cmluZywgTW9ja01lZGlhUXVlcnlMaXN0PjtcbiAgICBjb25zdHJ1Y3Rvcihfem9uZTogTmdab25lLCBfcGxhdGZvcm1JZDogT2JqZWN0LCBfZG9jdW1lbnQ6IGFueSwgX2JyZWFrcG9pbnRzOiBCcmVha1BvaW50UmVnaXN0cnkpO1xuICAgIC8qKiBFYXN5IG1ldGhvZCB0byBjbGVhciBhbGwgbGlzdGVuZXJzIGZvciBhbGwgbWVkaWFRdWVyaWVzICovXG4gICAgY2xlYXJBbGwoKTogdm9pZDtcbiAgICAvKiogRmVhdHVyZSB0byBzdXBwb3J0IG1hbnVhbCwgc2ltdWxhdGVkIGFjdGl2YXRpb24gb2YgYSBtZWRpYVF1ZXJ5LiAqL1xuICAgIGFjdGl2YXRlKG1lZGlhUXVlcnk6IHN0cmluZywgdXNlT3ZlcmxhcHM/OiBib29sZWFuKTogYm9vbGVhbjtcbiAgICAvKiogQ29udmVydHMgYW4gb3B0aW9uYWwgbWVkaWFRdWVyeSBhbGlhcyB0byBhIHNwZWNpZmljLCB2YWxpZCBtZWRpYVF1ZXJ5ICovXG4gICAgX3ZhbGlkYXRlUXVlcnkocXVlcnlPckFsaWFzOiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgYWN0aXZhdGUgYW55IG92ZXJsYXBwaW5nIG1lZGlhUXVlcmllcyB0byBzaW11bGF0ZVxuICAgICAqIHNpbWlsYXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgd2luZG93Lm1hdGNoTWVkaWEoKVxuICAgICAqL1xuICAgIHByaXZhdGUgX2FjdGl2YXRlV2l0aE92ZXJsYXBzO1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfYWN0aXZhdGVCeUFsaWFzO1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfYWN0aXZhdGVCeVF1ZXJ5O1xuICAgIC8qKiBEZWFjdGl2YXRlIGFsbCBjdXJyZW50IE1vY2sgTVFMcyAqL1xuICAgIHByaXZhdGUgX2RlYWN0aXZhdGVBbGw7XG4gICAgLyoqIEluc3VyZSB0aGUgbWVkaWFRdWVyeSBpcyByZWdpc3RlcmVkIHdpdGggTWF0Y2hNZWRpYSAqL1xuICAgIHByaXZhdGUgX3JlZ2lzdGVyTWVkaWFRdWVyeTtcbiAgICAvKipcbiAgICAgKiBDYWxsIHdpbmRvdy5tYXRjaE1lZGlhKCkgdG8gYnVpbGQgYSBNZWRpYVF1ZXJ5TGlzdDsgd2hpY2hcbiAgICAgKiBzdXBwb3J0cyAwLi5uIGxpc3RlbmVycyBmb3IgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb25cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2J1aWxkTVFMKHF1ZXJ5OiBzdHJpbmcpOiBNZWRpYVF1ZXJ5TGlzdDtcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgaGFzQWN0aXZhdGVkOiBib29sZWFuO1xuICAgIHByaXZhdGUgX2FjdGl2ZXM7XG59XG4vKipcbiAqIFNwZWNpYWwgaW50ZXJuYWwgY2xhc3MgdG8gc2ltdWxhdGUgYSBNZWRpYVF1ZXJ5TGlzdCBhbmRcbiAqIC0gc3VwcG9ydHMgbWFudWFsIGFjdGl2YXRpb24gdG8gc2ltdWxhdGUgbWVkaWFRdWVyeSBtYXRjaGluZ1xuICogLSBtYW5hZ2VzIGxpc3RlbmVyc1xuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNb2NrTWVkaWFRdWVyeUxpc3QgaW1wbGVtZW50cyBNZWRpYVF1ZXJ5TGlzdCB7XG4gICAgcHJpdmF0ZSBfbWVkaWFRdWVyeTtcbiAgICBwcml2YXRlIF9pc0FjdGl2ZTtcbiAgICBwcml2YXRlIF9saXN0ZW5lcnM7XG4gICAgcmVhZG9ubHkgbWF0Y2hlczogYm9vbGVhbjtcbiAgICByZWFkb25seSBtZWRpYTogc3RyaW5nO1xuICAgIGNvbnN0cnVjdG9yKF9tZWRpYVF1ZXJ5OiBzdHJpbmcpO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGN1cnJlbnQgbGlzdCBieSBkZWFjdGl2YXRpbmcgdGhlXG4gICAgICogbGlzdGVuZXJzIGFuZCBjbGVhcmluZyB0aGUgaW50ZXJuYWwgbGlzdFxuICAgICAqL1xuICAgIGRlc3Ryb3koKTogdm9pZDtcbiAgICAvKiogTm90aWZ5IGFsbCBsaXN0ZW5lcnMgdGhhdCAnbWF0Y2hlcyA9PT0gVFJVRScgKi9cbiAgICBhY3RpdmF0ZSgpOiBNb2NrTWVkaWFRdWVyeUxpc3Q7XG4gICAgLyoqIE5vdGlmeSBhbGwgbGlzdGVuZXJzIHRoYXQgJ21hdGNoZXMgPT09IGZhbHNlJyAqL1xuICAgIGRlYWN0aXZhdGUoKTogTW9ja01lZGlhUXVlcnlMaXN0O1xuICAgIC8qKiBBZGQgYSBsaXN0ZW5lciB0byBvdXIgaW50ZXJuYWwgbGlzdCB0byBhY3RpdmF0ZSBsYXRlciAqL1xuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyOiBNZWRpYVF1ZXJ5TGlzdExpc3RlbmVyKTogdm9pZDtcbiAgICAvKiogRG9uJ3QgbmVlZCB0byByZW1vdmUgbGlzdGVuZXJzIGluIHRoZSB0ZXN0aW5nIGVudmlyb25tZW50ICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoXzogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwpOiB2b2lkO1xuICAgIGFkZEV2ZW50TGlzdGVuZXI8SyBleHRlbmRzIGtleW9mIE1lZGlhUXVlcnlMaXN0RXZlbnRNYXA+KF86IEssIF9fOiAodGhpczogTWVkaWFRdWVyeUxpc3QsIGV2OiBNZWRpYVF1ZXJ5TGlzdEV2ZW50TWFwW0tdKSA9PiBhbnksIF9fXz86IGJvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyk6IHZvaWQ7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgTWVkaWFRdWVyeUxpc3RFdmVudE1hcD4oXzogSywgX186ICh0aGlzOiBNZWRpYVF1ZXJ5TGlzdCwgZXY6IE1lZGlhUXVlcnlMaXN0RXZlbnRNYXBbS10pID0+IGFueSwgX19fPzogYm9vbGVhbiB8IEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdm9pZDtcbiAgICBkaXNwYXRjaEV2ZW50KF86IEV2ZW50KTogYm9vbGVhbjtcbiAgICBvbmNoYW5nZTogTWVkaWFRdWVyeUxpc3RMaXN0ZW5lcjtcbn1cbi8qKlxuICogUHJlLWNvbmZpZ3VyZWQgcHJvdmlkZXIgZm9yIE1vY2tNYXRjaE1lZGlhXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE1vY2tNYXRjaE1lZGlhUHJvdmlkZXI6IHtcbiAgICBwcm92aWRlOiB0eXBlb2YgTWF0Y2hNZWRpYTtcbiAgICB1c2VDbGFzczogdHlwZW9mIE1vY2tNYXRjaE1lZGlhO1xufTtcbmRlY2xhcmUgdHlwZSBNZWRpYVF1ZXJ5TGlzdExpc3RlbmVyID0gKCh0aGlzOiBNZWRpYVF1ZXJ5TGlzdCwgZXY6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IGFueSkgfCBudWxsO1xuZXhwb3J0IHt9O1xuIl19