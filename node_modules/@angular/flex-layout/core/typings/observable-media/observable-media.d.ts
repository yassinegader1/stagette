import { Observable, PartialObserver, Subscribable, Subscription } from 'rxjs';
import { BreakPointRegistry } from '../breakpoints/break-point-registry';
import { MediaChange } from '../media-change';
import { MatchMedia } from '../match-media/match-media';
/**
 * Base class for MediaService and pseudo-token for
 */
import * as ɵngcc0 from '@angular/core';
export declare abstract class ObservableMedia implements Subscribable<MediaChange> {
    abstract isActive(query: string): boolean;
    abstract asObservable(): Observable<MediaChange>;
    abstract subscribe(next?: (value: MediaChange) => void, error?: (error: any) => void, complete?: () => void): Subscription;
    abstract subscribe(observer?: PartialObserver<MediaChange>): Subscription;
}
/**
 * Class internalizes a MatchMedia service and exposes an Subscribable and Observable interface.

 * This an Observable with that exposes a feature to subscribe to mediaQuery
 * changes and a validator method (`isActive(<alias>)`) to test if a mediaQuery (or alias) is
 * currently active.
 *
 * !! Only mediaChange activations (not de-activations) are announced by the ObservableMedia
 *
 * This class uses the BreakPoint Registry to inject alias information into the raw MediaChange
 * notification. For custom mediaQuery notifications, alias information will not be injected and
 * those fields will be ''.
 *
 * !! This is not an actual Observable. It is a wrapper of an Observable used to publish additional
 * methods like `isActive(<alias>). To access the Observable and use RxJS operators, use
 * `.asObservable()` with syntax like media.asObservable().map(....).
 *
 *  @usage
 *
 *  // RxJS
 *  import {filter} from 'rxjs/operators/filter';
 *  import { ObservableMedia } from '@angular/flex-layout';
 *
 *  @Component({ ... })
 *  export class AppComponent {
 *    status : string = '';
 *
 *    constructor(  media:ObservableMedia ) {
 *      let onChange = (change:MediaChange) => {
 *        this.status = change ? `'${change.mqAlias}' = (${change.mediaQuery})` : '';
 *      };
 *
 *      // Subscribe directly or access observable to use filter/map operators
 *      // e.g.
 *      //      media.subscribe(onChange);
 *
 *      media.asObservable()
 *        .pipe(
 *          filter((change:MediaChange) => true)   // silly noop filter
 *        ).subscribe(onChange);
 *    }
 *  }
 */
export declare class MediaService implements ObservableMedia {
    private breakpoints;
    private mediaWatcher;
    /**
     * Should we announce gt-<xxx> breakpoint activations ?
     */
    filterOverlaps: boolean;
    constructor(breakpoints: BreakPointRegistry, mediaWatcher: MatchMedia);
    /**
     * Test if specified query/alias is active.
     */
    isActive(alias: string): boolean;
    /**
     * Proxy to the Observable subscribe method
     */
    subscribe(observerOrNext?: PartialObserver<MediaChange> | ((value: MediaChange) => void), error?: (error: any) => void, complete?: () => void): Subscription;
    /**
     * Access to observable for use with operators like
     * .filter(), .map(), etc.
     */
    asObservable(): Observable<MediaChange>;
    /**
     * Register all the mediaQueries registered in the BreakPointRegistry
     * This is needed so subscribers can be auto-notified of all standard, registered
     * mediaQuery activations
     */
    private _registerBreakPoints;
    /**
     * Prepare internal observable
     *
     * NOTE: the raw MediaChange events [from MatchMedia] do not
     *       contain important alias information; as such this info
     *       must be injected into the MediaChange
     */
    private _buildObservable;
    /**
     * Breakpoint locator by alias
     */
    private _findByAlias;
    /**
     * Breakpoint locator by mediaQuery
     */
    private _findByQuery;
    /**
     * Find associated breakpoint (if any)
     */
    private _toMediaQuery;
    private readonly observable$;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MediaService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<MediaService>;
}
export declare const ObservableMediaProvider: {
    provide: typeof ObservableMedia;
    useClass: typeof MediaService;
};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JzZXJ2YWJsZS1tZWRpYS5kLnRzIiwic291cmNlcyI6WyJvYnNlcnZhYmxlLW1lZGlhLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBQYXJ0aWFsT2JzZXJ2ZXIsIFN1YnNjcmliYWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBCcmVha1BvaW50UmVnaXN0cnkgfSBmcm9tICcuLi9icmVha3BvaW50cy9icmVhay1wb2ludC1yZWdpc3RyeSc7XG5pbXBvcnQgeyBNZWRpYUNoYW5nZSB9IGZyb20gJy4uL21lZGlhLWNoYW5nZSc7XG5pbXBvcnQgeyBNYXRjaE1lZGlhIH0gZnJvbSAnLi4vbWF0Y2gtbWVkaWEvbWF0Y2gtbWVkaWEnO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBNZWRpYVNlcnZpY2UgYW5kIHBzZXVkby10b2tlbiBmb3JcbiAqL1xuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgT2JzZXJ2YWJsZU1lZGlhIGltcGxlbWVudHMgU3Vic2NyaWJhYmxlPE1lZGlhQ2hhbmdlPiB7XG4gICAgYWJzdHJhY3QgaXNBY3RpdmUocXVlcnk6IHN0cmluZyk6IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgYXNPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8TWVkaWFDaGFuZ2U+O1xuICAgIGFic3RyYWN0IHN1YnNjcmliZShuZXh0PzogKHZhbHVlOiBNZWRpYUNoYW5nZSkgPT4gdm9pZCwgZXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gdm9pZCwgY29tcGxldGU/OiAoKSA9PiB2b2lkKTogU3Vic2NyaXB0aW9uO1xuICAgIGFic3RyYWN0IHN1YnNjcmliZShvYnNlcnZlcj86IFBhcnRpYWxPYnNlcnZlcjxNZWRpYUNoYW5nZT4pOiBTdWJzY3JpcHRpb247XG59XG4vKipcbiAqIENsYXNzIGludGVybmFsaXplcyBhIE1hdGNoTWVkaWEgc2VydmljZSBhbmQgZXhwb3NlcyBhbiBTdWJzY3JpYmFibGUgYW5kIE9ic2VydmFibGUgaW50ZXJmYWNlLlxuXG4gKiBUaGlzIGFuIE9ic2VydmFibGUgd2l0aCB0aGF0IGV4cG9zZXMgYSBmZWF0dXJlIHRvIHN1YnNjcmliZSB0byBtZWRpYVF1ZXJ5XG4gKiBjaGFuZ2VzIGFuZCBhIHZhbGlkYXRvciBtZXRob2QgKGBpc0FjdGl2ZSg8YWxpYXM+KWApIHRvIHRlc3QgaWYgYSBtZWRpYVF1ZXJ5IChvciBhbGlhcykgaXNcbiAqIGN1cnJlbnRseSBhY3RpdmUuXG4gKlxuICogISEgT25seSBtZWRpYUNoYW5nZSBhY3RpdmF0aW9ucyAobm90IGRlLWFjdGl2YXRpb25zKSBhcmUgYW5ub3VuY2VkIGJ5IHRoZSBPYnNlcnZhYmxlTWVkaWFcbiAqXG4gKiBUaGlzIGNsYXNzIHVzZXMgdGhlIEJyZWFrUG9pbnQgUmVnaXN0cnkgdG8gaW5qZWN0IGFsaWFzIGluZm9ybWF0aW9uIGludG8gdGhlIHJhdyBNZWRpYUNoYW5nZVxuICogbm90aWZpY2F0aW9uLiBGb3IgY3VzdG9tIG1lZGlhUXVlcnkgbm90aWZpY2F0aW9ucywgYWxpYXMgaW5mb3JtYXRpb24gd2lsbCBub3QgYmUgaW5qZWN0ZWQgYW5kXG4gKiB0aG9zZSBmaWVsZHMgd2lsbCBiZSAnJy5cbiAqXG4gKiAhISBUaGlzIGlzIG5vdCBhbiBhY3R1YWwgT2JzZXJ2YWJsZS4gSXQgaXMgYSB3cmFwcGVyIG9mIGFuIE9ic2VydmFibGUgdXNlZCB0byBwdWJsaXNoIGFkZGl0aW9uYWxcbiAqIG1ldGhvZHMgbGlrZSBgaXNBY3RpdmUoPGFsaWFzPikuIFRvIGFjY2VzcyB0aGUgT2JzZXJ2YWJsZSBhbmQgdXNlIFJ4SlMgb3BlcmF0b3JzLCB1c2VcbiAqIGAuYXNPYnNlcnZhYmxlKClgIHdpdGggc3ludGF4IGxpa2UgbWVkaWEuYXNPYnNlcnZhYmxlKCkubWFwKC4uLi4pLlxuICpcbiAqICBAdXNhZ2VcbiAqXG4gKiAgLy8gUnhKU1xuICogIGltcG9ydCB7ZmlsdGVyfSBmcm9tICdyeGpzL29wZXJhdG9ycy9maWx0ZXInO1xuICogIGltcG9ydCB7IE9ic2VydmFibGVNZWRpYSB9IGZyb20gJ0Bhbmd1bGFyL2ZsZXgtbGF5b3V0JztcbiAqXG4gKiAgQENvbXBvbmVudCh7IC4uLiB9KVxuICogIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICAgc3RhdHVzIDogc3RyaW5nID0gJyc7XG4gKlxuICogICAgY29uc3RydWN0b3IoICBtZWRpYTpPYnNlcnZhYmxlTWVkaWEgKSB7XG4gKiAgICAgIGxldCBvbkNoYW5nZSA9IChjaGFuZ2U6TWVkaWFDaGFuZ2UpID0+IHtcbiAqICAgICAgICB0aGlzLnN0YXR1cyA9IGNoYW5nZSA/IGAnJHtjaGFuZ2UubXFBbGlhc30nID0gKCR7Y2hhbmdlLm1lZGlhUXVlcnl9KWAgOiAnJztcbiAqICAgICAgfTtcbiAqXG4gKiAgICAgIC8vIFN1YnNjcmliZSBkaXJlY3RseSBvciBhY2Nlc3Mgb2JzZXJ2YWJsZSB0byB1c2UgZmlsdGVyL21hcCBvcGVyYXRvcnNcbiAqICAgICAgLy8gZS5nLlxuICogICAgICAvLyAgICAgIG1lZGlhLnN1YnNjcmliZShvbkNoYW5nZSk7XG4gKlxuICogICAgICBtZWRpYS5hc09ic2VydmFibGUoKVxuICogICAgICAgIC5waXBlKFxuICogICAgICAgICAgZmlsdGVyKChjaGFuZ2U6TWVkaWFDaGFuZ2UpID0+IHRydWUpICAgLy8gc2lsbHkgbm9vcCBmaWx0ZXJcbiAqICAgICAgICApLnN1YnNjcmliZShvbkNoYW5nZSk7XG4gKiAgICB9XG4gKiAgfVxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBNZWRpYVNlcnZpY2UgaW1wbGVtZW50cyBPYnNlcnZhYmxlTWVkaWEge1xuICAgIHByaXZhdGUgYnJlYWtwb2ludHM7XG4gICAgcHJpdmF0ZSBtZWRpYVdhdGNoZXI7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHdlIGFubm91bmNlIGd0LTx4eHg+IGJyZWFrcG9pbnQgYWN0aXZhdGlvbnMgP1xuICAgICAqL1xuICAgIGZpbHRlck92ZXJsYXBzOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGJyZWFrcG9pbnRzOiBCcmVha1BvaW50UmVnaXN0cnksIG1lZGlhV2F0Y2hlcjogTWF0Y2hNZWRpYSk7XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBzcGVjaWZpZWQgcXVlcnkvYWxpYXMgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlKGFsaWFzOiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByb3h5IHRvIHRoZSBPYnNlcnZhYmxlIHN1YnNjcmliZSBtZXRob2RcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUob2JzZXJ2ZXJPck5leHQ/OiBQYXJ0aWFsT2JzZXJ2ZXI8TWVkaWFDaGFuZ2U+IHwgKCh2YWx1ZTogTWVkaWFDaGFuZ2UpID0+IHZvaWQpLCBlcnJvcj86IChlcnJvcjogYW55KSA9PiB2b2lkLCBjb21wbGV0ZT86ICgpID0+IHZvaWQpOiBTdWJzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogQWNjZXNzIHRvIG9ic2VydmFibGUgZm9yIHVzZSB3aXRoIG9wZXJhdG9ycyBsaWtlXG4gICAgICogLmZpbHRlcigpLCAubWFwKCksIGV0Yy5cbiAgICAgKi9cbiAgICBhc09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxNZWRpYUNoYW5nZT47XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYWxsIHRoZSBtZWRpYVF1ZXJpZXMgcmVnaXN0ZXJlZCBpbiB0aGUgQnJlYWtQb2ludFJlZ2lzdHJ5XG4gICAgICogVGhpcyBpcyBuZWVkZWQgc28gc3Vic2NyaWJlcnMgY2FuIGJlIGF1dG8tbm90aWZpZWQgb2YgYWxsIHN0YW5kYXJkLCByZWdpc3RlcmVkXG4gICAgICogbWVkaWFRdWVyeSBhY3RpdmF0aW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgX3JlZ2lzdGVyQnJlYWtQb2ludHM7XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBpbnRlcm5hbCBvYnNlcnZhYmxlXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGUgcmF3IE1lZGlhQ2hhbmdlIGV2ZW50cyBbZnJvbSBNYXRjaE1lZGlhXSBkbyBub3RcbiAgICAgKiAgICAgICBjb250YWluIGltcG9ydGFudCBhbGlhcyBpbmZvcm1hdGlvbjsgYXMgc3VjaCB0aGlzIGluZm9cbiAgICAgKiAgICAgICBtdXN0IGJlIGluamVjdGVkIGludG8gdGhlIE1lZGlhQ2hhbmdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBfYnVpbGRPYnNlcnZhYmxlO1xuICAgIC8qKlxuICAgICAqIEJyZWFrcG9pbnQgbG9jYXRvciBieSBhbGlhc1xuICAgICAqL1xuICAgIHByaXZhdGUgX2ZpbmRCeUFsaWFzO1xuICAgIC8qKlxuICAgICAqIEJyZWFrcG9pbnQgbG9jYXRvciBieSBtZWRpYVF1ZXJ5XG4gICAgICovXG4gICAgcHJpdmF0ZSBfZmluZEJ5UXVlcnk7XG4gICAgLyoqXG4gICAgICogRmluZCBhc3NvY2lhdGVkIGJyZWFrcG9pbnQgKGlmIGFueSlcbiAgICAgKi9cbiAgICBwcml2YXRlIF90b01lZGlhUXVlcnk7XG4gICAgcHJpdmF0ZSByZWFkb25seSBvYnNlcnZhYmxlJDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE9ic2VydmFibGVNZWRpYVByb3ZpZGVyOiB7XG4gICAgcHJvdmlkZTogdHlwZW9mIE9ic2VydmFibGVNZWRpYTtcbiAgICB1c2VDbGFzczogdHlwZW9mIE1lZGlhU2VydmljZTtcbn07XG4iXX0=